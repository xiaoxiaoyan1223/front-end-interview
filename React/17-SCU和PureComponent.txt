更新机制
Component：每次状态或props发生变化时，React.Component都会重新渲染，不论值是否与之前的相等。这可能导致不必要的渲染，从而影响性能。
PureComponent：React.PureComponent通过实现shouldComponentUpdate方法来进行性能优化。它比较当前和下一个状态（以及props）的浅层属性，如果发现没有变化，则不会触发渲染。这意味着，对于基本数据类型（如字符串、数字），PureComponent能够避免不必要的渲染，但对于引用类型的数据（如对象、数组），只有引用地址变化时才会认为它们发生了变化。
性能优化
Component：由于每次state或props更新都会触发渲染，未经过任何比较，所以在性能上可能不如PureComponent。
PureComponent：通过浅比较props和state来避免不必要的渲染，从而提高性能。但如果prop或state每次都发生变化，使用Component可能更有效，因为浅比较本身也需要时间。
实现细节
Component：开发者需要手动实现shouldComponentUpdate方法来决定组件是否应该更新，否则默认行为是总是重新渲染。
PureComponent：内部自动实现了基于props和state浅比较的shouldComponentUpdate方法，开发者无需手动实现。
使用场景
Component：适用于渲染结果不仅依赖props和state，或者props和state不容易进行比较的情况。
PureComponent：适合渲染结果只依赖于其props和state，且这些props和state是可比较的（例如，基本类型或具有稳定引用的对象）。在这种情况下，使用PureComponent可以有效提高性能。
注意事项
Component：如果不实现shouldComponentUpdate，将无法阻止不必要的渲染。
PureComponent：需要注意的是，如果直接对传入的对象或数组进行赋值操作，由于没有改变引用地址，PureComponent就不会触发重新渲染。此外，在PureComponent中使用shouldComponentUpdate方法会产生警告，因为它已经内置了浅比较逻辑。
对比示例
Component：在React.Component中，每次setState调用后，即使state的值没有实质变化，组件也会重新渲染。
PureComponent：React.PureComponent通过浅比较避免了没有变化的重新渲染。例如，当state中的基本类型值未改变时，不会触发render方法。
深层比较
Component：没有内置深层比较机制，需要开发者自行实现。
PureComponent：仅限于浅比较，对于深层的prop或state变化，无法检测到。若需要深层比较，可能需要借助其他库如ImmutableJS来实现。
DOM更新
Component：即使React元素相同，每次渲染也可能导致虚拟DOM的比对和可能的DOM更新。
PureComponent：如果渲染的React元素没有变化，可以避免虚拟DOM比对和DOM更新，进一步优化性能。
